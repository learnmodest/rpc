### Writing a Discard Server

The most simplistic protocol in the world is not 'Hello, World!' but [`DISCARD`](https://tools.ietf.org/html/rfc863). It's a protocol which discards any received data without any response.

> 世界上最简单的协议不是“Hello World”而是DISCARD，该协议丢弃所有接受到的数据并且没有任何响应。

To implement the `DISCARD` protocol, the only thing you need to do is to ignore all received data. Let us start straight from the handler implementation, which handles I/O events generated by Netty.

> 仅需要忽略所有接受的数据就可以实现DISCARD协议。我们将直接从handler实现开始讲解，handler实现用来处理Netty生成的各种I/O事件。

~~~java
package io.netty.example.discard;

import io.netty.buffer.ByteBuf;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelHandlerAdapter;

/**
 * Handles a server-side channel.
 */
public class DiscardServerHandler extends ChannelHandlerAdapter { // (1)

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) { // (2)
        // Discard the received data silently.
        ((ByteBuf) msg).release(); // (3)
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { // (4)
        // Close the connection when an exception is raised.
        cause.printStackTrace();
        ctx.close();
    }
}
~~~

1. `DiscardServerHandler` extends [`ChannelHandlerAdapter`](https://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html), which is an implementation of [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html). [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) provides various event handler methods that you can override. For now, it is just enough to extend [`ChannelHandlerAdapter`](https://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html) rather than to implement the handler interface by yourself.

   > DiscardServerHandler 继承 ChannelHandlerAdapter，ChannelHandlerAdapter实现了接口ChannelHandler，ChannelHandler提供了大量可被重写的事件处理器方法。不用自己实现这个接口，直接继承ChannelHandlerAdapter就可以。

2. We override the `channelRead()` event handler method here. This method is called with the received message, whenever new data is received from a client. In this example, the type of the received message is [`ByteBuf`](https://netty.io/5.0/api/io/netty/buffer/ByteBuf.html).

   > 在DiscardServerHandler 重写了channelRead()事件处理器方法，**该方法在服务端接收来自客户端的新消息时会被调用**，这些消息的类型为ByteBuf。

3. To implement the `DISCARD` protocol, the handler has to ignore the received message. [`ByteBuf`](https://netty.io/5.0/api/io/netty/buffer/ByteBuf.html) is a reference-counted object which has to be released explicitly via the `release()` method. Please keep in mind that it is the handler's responsibility to release any reference-counted object passed to the handler. Usually, `channelRead()` handler method is implemented like the following:

   > 为了实现DISCARD协议，处理器需要忽略接收到的消息。ByteBuf 是一个引用计数的对象，必须通过 release ()方法显式地释放它。要注意的是，该处理器的作用就是释放所有接收到的引用计数对象。通常情况下，channelRead()处理器方法应该这样写：

   ~~~java
   @Override
   public void channelRead(ChannelHandlerContext ctx, Object msg) {
       try {
           // Do something with msg
       } finally {
           ReferenceCountUtil.release(msg);
       }
   }
   ~~~

4. The `exceptionCaught()` event handler method is called with a `Throwable` when an exception was raised by Netty due to an I/O error or by a handler implementation due to the exception thrown while processing events. In most cases, the caught exception should be logged and its associated channel should be closed here, although the implementation of this method can be different depending on what you want to do to deal with an exceptional situation. For example, you might want to send a response message with an error code before closing the connection.

   > 当Netty由于I/O抛出异常，或者处理器实现类在处理事件时抛出异常，**exceptionCaught()**事件处理器方法就会被调用。大多数情况下，抛出的异常应该被记录，和它相关的管道也应当被关闭。

We have implemented the first half of the `DISCARD` server. What's left now is to write the `main()` method which starts the server with the `DiscardServerHandler`.

> 迄今为止，我们已经实现了DISCARD服务端的一半，现在剩下的是编写 main ()方法，该方法使用 DiscardServerHandler 启动服务器。

~~~java
package io.netty.example.discard;
    
import io.netty.bootstrap.ServerBootstrap;

import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
    
/**
 * Discards any incoming data.
 */
public class DiscardServer {
    
    private int port;
    
    public DiscardServer(int port) {
        this.port = port;
    }
    
    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup(); // (1)
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap(); // (2)
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class) // (3)
             .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
                     ch.pipeline().addLast(new DiscardServerHandler());
                 }
             })
             .option(ChannelOption.SO_BACKLOG, 128)          // (5)
             .childOption(ChannelOption.SO_KEEPALIVE, true); // (6)
    
            // Bind and start to accept incoming connections.
            ChannelFuture f = b.bind(port).sync(); // (7)
    
            // Wait until the server socket is closed.
            // In this example, this does not happen, but you can do that to gracefully
            // shut down your server.
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
    
    public static void main(String[] args) throws Exception {
        int port;
        if (args.length > 0) {
            port = Integer.parseInt(args[0]);
        } else {
            port = 8080;
        }
        new DiscardServer(port).run();
    }
}
~~~

1. [`NioEventLoopGroup`](https://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html) is a multithreaded event loop that handles I/O operation. Netty provides various [`EventLoopGroup`](https://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html) implementations for different kind of transports. We are implementing a server-side application in this example, and therefore two [`NioEventLoopGroup`](https://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html) will be used. The first one, often called 'boss', accepts an incoming connection. The second one, often called 'worker', handles the traffic of the accepted connection once the boss accepts the connection and registers the accepted connection to the worker. How many Threads are used and how they are mapped to the created [`Channel`](https://netty.io/5.0/api/io/netty/channel/Channel.html)s depends on the [`EventLoopGroup`](https://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html) implementation and may be even configurable via a constructor.

   > NioEventLoopGroup 是一个处理 I/O 操作的多线程事件循环，Netty为不同类型的传输提供了各种EventLoopGroup实现。在这个示例中，我们正在实现一个服务器端应用程序，因此将使用两个 NioEventLoopGroup。第一个叫做‘boss’，接收传入连接，第二个叫做‘worker’，在‘boss’接收连接并将其注册给‘worker’时，‘worker’会处理这些接收的连接。使用多少线程以及怎么映射这些线程到Channel，取决于具体的EventLoopGroup实现，可以通过构造函数进行配置。

2. [`ServerBootstrap`](https://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html) is a helper class that sets up a server. You can set up the server using a [`Channel`](https://netty.io/5.0/api/io/netty/channel/Channel.html) directly. However, please note that this is a tedious process, and you do not need to do that in most cases.

   > ServerBootStrap 类用来帮助创建服务端，虽然你可以直接使用一个Channel创建服务器，但是创建过程极其繁琐，大多数情况下你都没必要这样做。

3. Here, we specify to use the [`NioServerSocketChannel`](https://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html) class which is used to instantiate a new [`Channel`](https://netty.io/5.0/api/io/netty/channel/Channel.html) to accept incoming connections.

   > 在这个示例中，我们指定使用NioServerSocketChannel类来实例化一个新的Channel，来接收传入连接

4. The handler specified here will always be evaluated by a newly accepted [`Channel`](https://netty.io/5.0/api/io/netty/channel/Channel.html). The [`ChannelInitializer`](https://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html) is a special handler that is purposed to help a user configure a new [`Channel`](https://netty.io/5.0/api/io/netty/channel/Channel.html). It is most likely that you want to configure the [`ChannelPipeline`](https://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html) of the new [`Channel`](https://netty.io/5.0/api/io/netty/channel/Channel.html) by adding some handlers such as `DiscardServerHandler` to implement your network application. As the application gets complicated, it is likely that you will add more handlers to the pipeline and extract this anonymous class into a top level class eventually.

   > 指定的处理器将始终由一个新接受的 Channel 进行判定，ChannelInitializer 是一个特殊的handler，用于初始化channel，比如向Channel中添加各种handler(比如DiscardServerHandler)。随着应用程序变得复杂，您可能会向Channel添加更多的handler，并最终将这个匿名类提取到顶级类中。

5. You can also set the parameters which are specific to the `Channel` implementation. We are writing a TCP/IP server, so we are allowed to set the socket options such as `tcpNoDelay` and `keepAlive`. Please refer to the apidocs of [`ChannelOption`](https://netty.io/5.0/api/io/netty/channel/ChannelOption.html) and the specific [`ChannelConfig`](https://netty.io/5.0/api/io/netty/channel/ChannelConfig.html) implementations to get an overview about the supported `ChannelOption`s.

   >还可以设置指定Channel 实现的参数，这是一个TCP/IP服务器，所以可以设置tcpNoDelay、keepAlive之类的socket配置。通过ChannelOption的api文档和指定的ChannelConfig实现，可以全面了解合法的ChannelOptions。

6. Did you notice `option()` and `childOption()`? `option()` is for the [`NioServerSocketChannel`](https://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html) that accepts incoming connections. `childOption()` is for the [`Channel`](https://netty.io/5.0/api/io/netty/channel/Channel.html)s accepted by the parent [`ServerChannel`](https://netty.io/5.0/api/io/netty/channel/ServerChannel.html), which is [`NioServerSocketChannel`](https://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html) in this case.

   > option()用来配置ServerChannel(本实例的ServerChannel是NioServerSocketChannel)，ServerChannle监听所有的连接，在bind()/connect()方法被调用时创建，每个服务端只有一个；ServerChannel在接收到客户端连接时，就会创建一个child channel，而childOption()就是用来配置这些child channel的，一个Server有多个child channel。ServerBootStrap中的attr和childAttr、handler和childHandler是同样的逻辑。
   >
   > 参考：[What is the difference between ServerBootstrap.option() and ServerBootstrap.childOption() in netty 4.x](https://stackoverflow.com/questions/35496345/what-is-the-difference-between-serverbootstrap-option-and-serverbootstrap-child)

7. We are ready to go now. What's left is to bind to the port and to start the server. Here, we bind to the port `8080` of all NICs (network interface cards) in the machine. You can now call the `bind()` method as many times as you want (with different bind addresses.)

   > 剩下的就是绑定端口，然后启动服务器

### Looking into the Received Data

Now that we have written our first server, we need to test if it really works. The easiest way to test it is to use the *telnet* command. For example, you could enter `telnet localhost 8080` in the command line and type something.

> 使用telnet命令来测试Server端是否真的生效，在命令行输入`telnet localhost 8080`并敲一些内容

However, can we say that the server is working fine? We cannot really know that because it is a discard server. You will not get any response at all. To prove it is really working, let us modify the server to print what it has received.

> 因为第一版的Server是一个DISCARD SERVER，所以无法判断它是否接收到了发的请求。需要改下代码

We already know that `channelRead()` method is invoked whenever data is received. Let us put some code into the `channelRead()` method of the `DiscardServerHandler`:

> channelRead()是用来处理数据的方法，所以在这里面改

~~~java
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf in = (ByteBuf) msg;
    try {
        while (in.isReadable()) { // (1)
            //打印接收到的消息
            System.out.print((char) in.readByte());
            System.out.flush();
        }
    } finally {
        ReferenceCountUtil.release(msg); // (2)
    }
}
~~~

### Writing an Echo Server

So far, we have been consuming data without responding at all. A server, however, is usually supposed to respond to a request. Let us learn how to write a response message to a client by implementing the [`ECHO`](https://tools.ietf.org/html/rfc862) protocol, where any received data is sent back.

> 迄今为止，写的这个Server只进不出，改改代码，让它说两句。

The only difference from the discard server we have implemented in the previous sections is that it sends the received data back instead of printing the received data out to the console. Therefore, it is enough again to modify the `channelRead()` method:

>之前Server接受的消息会打印在控制台，现在把消息原封不动的还给调用方，“回声”Server

~~~java
   @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ctx.write(msg); // (1)
        ctx.flush(); // (2)
    }
~~~

1. A [`ChannelHandlerContext`](https://netty.io/5.0/api/io/netty/channel/ChannelHandlerContext.html) object provides various operations that enable you to trigger various I/O events and operations. Here, we invoke `write(Object)` to write the received message in verbatim. Please note that we did not release the received message unlike we did in the `DISCARD` example. It is because Netty releases it for you when it is written out to the wire.

   > ChannelHandlerContext对象提供多种操作，利用它可以触发各种I/O事件和操作，在该实例中，调用write(Object)逐字的写收到的消息。不用再手动释放接受的消息，因为Netty会在消息被写到网络中后，自动将其释放。

2. `ctx.write(Object)` does not make the message written out to the wire. It is buffered internally, and then flushed out to the wire by `ctx.flush()`. Alternatively, you could call `ctx.writeAndFlush(msg)` for brevity.

   > ctx.write(Object) 方法没有将消息写到网络中，消息被内部缓存，由ctx.flush()写到网络中。也可以直接调用`ctx.writeAndFlush(msg)`来简化操作

### Writing a Time Server

The protocol to implement in this section is the [`TIME`](https://tools.ietf.org/html/rfc868) protocol. It is different from the previous examples in that it sends a message, which contains a 32-bit integer, without receiving any requests and closes the connection once the message is sent. In this example, you will learn how to construct and send a message, and to close the connection on completion.

> 写个Time Server，特点是不接收任何请求，只发一条包含一个32位整数消息，发完就自闭。通过这个示例学习怎么构建和发送消息，以及如何在消息发送后关闭连接。

Because we are going to ignore any received data but to send a message as soon as a connection is established, we cannot use the `channelRead()` method this time. Instead, we should override the `channelActive()` method. The following is the implementation:

> 忽略所有接收的数据，连接一建立就立即发一条消息，使用channelRead()就不太合适了，需要重写channelActive()方法来实现这个功能。

```java
package io.netty.example.time;

public class TimeServerHandler extends ChannelHandlerAdapter {

    @Override
    public void channelActive(final ChannelHandlerContext ctx) { // (1)
        //给消息分配缓存区空间
        final ByteBuf time = ctx.alloc().buffer(4); // (2)
        //将消息写入缓存区
        time.writeInt((int) (System.currentTimeMillis() / 1000L + 2208988800L));
        
        //异步执行写和刷新的操作
        final ChannelFuture f = ctx.writeAndFlush(time); // (3)
        //为这个操作加个监听器，监听到操作完成时，关闭连接
        f.addListener(new ChannelFutureListener() {

            @Override
            public void operationComplete(ChannelFuture future) {
                assert f == future;
                ctx.close();
            }
        }); // (4)
    }
    
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}
```

1. As explained, the `channelActive()` method will be invoked when a connection is established and ready to generate traffic. Let's write a 32-bit integer that represents the current time in this method.

   > channelActive()在连接建立并准备产生交互时被调用，在方法中写一个32位整数代表当前时间

2. To send a new message, we need to allocate a new buffer which will contain the message. We are going to write a 32-bit integer, and therefore we need a [`ByteBuf`](https://netty.io/5.0/api/io/netty/buffer/ByteBuf.html) whose capacity is at least 4 bytes. Get the current [`ByteBufAllocator`](https://netty.io/5.0/api/io/netty/buffer/ByteBufAllocator.html) via `ChannelHandlerContext.alloc()` and allocate a new buffer.

   > 为了发送一条新消息，需要分配一块包含此消息的缓存区，因为要写一个32位的整数，所有需要一个容量至少为4字节的ByteBuf。通过channelHandlerContext.alloc()方法来创建ByteBufAllocator对象，并为其分配一块新的缓存区

3. As usual, we write the constructed message.

   But wait, where's the flip? Didn't we used to call `java.nio.ByteBuffer.flip()` before sending a message in NIO? `ByteBuf` does not have such a method because it has two pointers; one for read operations and the other for write operations. The writer index increases when you write something to a `ByteBuf` while the reader index does not change. The reader index and the writer index represents where the message starts and ends respectively.

   > `ByteBuf`有两个指针，一个读一个写。在向`ByteBuf`写数据时，写指针增长而读指针不变。读写指针分别代表消息开始和结束的位置。

   In contrast, NIO buffer does not provide a clean way to figure out where the message content starts and ends without calling the flip method. You will be in trouble when you forget to flip the buffer because nothing or incorrect data will be sent. Such an error does not happen in Netty because we have different pointer for different operation types. You will find it makes your life much easier as you get used to it -- a life without flipping out!

   > 使用Netty免去了调用flip方法的烦恼，让编程更轻松

   Another point to note is that the `ChannelHandlerContext.write()` (and `writeAndFlush()`) method returns a [`ChannelFuture`](https://netty.io/5.0/api/io/netty/channel/ChannelFuture.html). A [`ChannelFuture`](https://netty.io/5.0/api/io/netty/channel/ChannelFuture.html) represents an I/O operation which has not yet occurred. It means, any requested operation might not have been performed yet because all operations are asynchronous in Netty. For example, the following code might close the connection even before a message is sent:

   > 另一个需要关注的点是`ChannelHandlerContext.write()` (and `writeAndFlush()`) 方法会返回一个 [`ChannelFuture`](https://netty.io/5.0/api/io/netty/channel/ChannelFuture.html)。 [`ChannelFuture`](https://netty.io/5.0/api/io/netty/channel/ChannelFuture.html)代表一个还未发生的I/O操作，这意味着，任何请求的操作可能还没有执行，因为所有操作在 Netty 都是异步的。例如，下面的代码甚至可能在消息发送之前就关闭连接:

   ```
   Channel ch = ...;
   ch.writeAndFlush(message);
   ch.close();
   ```

   Therefore, you need to call the `close()` method after the [`ChannelFuture`](https://netty.io/5.0/api/io/netty/channel/ChannelFuture.html) is complete, which was returned by the `write()` method, and it notifies its listeners when the write operation has been done. Please note that, `close()` also might not close the connection immediately, and it returns a [`ChannelFuture`](https://netty.io/5.0/api/io/netty/channel/ChannelFuture.html).

   > 因此，当 `write()`方法返回的 [`ChannelFuture`](https://netty.io/5.0/api/io/netty/channel/ChannelFuture.html) 执行完成后，需要调用 `close()` 方法，它的作用是通知它的监听者写操作已经完成。需要注意的是， `close()` 方法可能也不会立即关闭连接，而是返回一个 [`ChannelFuture`](https://netty.io/5.0/api/io/netty/channel/ChannelFuture.html).

4. How do we get notified when a write request is finished then? This is as simple as adding a [`ChannelFutureListener`](https://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html) to the returned `ChannelFuture`. Here, we created a new anonymous [`ChannelFutureListener`](https://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html) which closes the `Channel` when the operation is done.

   Alternatively, you could simplify the code using a pre-defined listener:

   > 当请求完成时，怎么接收到通知呢？只需要为返回的 [`ChannelFuture`](https://netty.io/5.0/api/io/netty/channel/ChannelFuture.html).增加一个[`ChannelFutureListener`](https://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html) 监听器即可，在上面的代码中，创建了一个匿名的[`ChannelFutureListener`](https://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html) ，它在操作完成时会关闭`Channel` ，也可以直接使用预定义的监听器来简化代码。

   ```
   f.addListener(ChannelFutureListener.CLOSE);
   ```

To test if our time server works as expected, you can use the UNIX `rdate` command:

```
$ rdate -o <port> -p <host>
```

where `<port>` is the port number you specified in the `main()` method and `<host>` is usually `localhost`.

### Writing a Time Client

Unlike `DISCARD` and `ECHO` servers, we need a client for the `TIME` protocol because a human cannot translate a 32-bit binary data into a date on a calendar. In this section, we discuss how to make sure the server works correctly and learn how to write a client with Netty.

> 对于计时server来说，需要一个对应的client，把返回的32位二进制数据处理为日期类型。

The biggest and only difference between a server and a client in Netty is that different [`Bootstrap`](https://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html) and [`Channel`](https://netty.io/5.0/api/io/netty/channel/Channel.html) implementations are used. Please take a look at the following code:

> 在Netty中Server和Client最大也是仅有的区别是二者使用的不同的 [`Bootstrap`](https://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html) 和[`Channel`](https://netty.io/5.0/api/io/netty/channel/Channel.html) 实现类。

~~~java
package io.netty.example.time;

public class TimeClient {
    public static void main(String[] args) throws Exception {
        String host = args[0];
        int port = Integer.parseInt(args[1]);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            Bootstrap b = new Bootstrap(); // (1)
            b.group(workerGroup); // (2)
            b.channel(NioSocketChannel.class); // (3)
            b.option(ChannelOption.SO_KEEPALIVE, true); // (4)
            b.handler(new ChannelInitializer<SocketChannel>() {
                @Override
                public void initChannel(SocketChannel ch) throws Exception {
                    ch.pipeline().addLast(new TimeClientHandler());
                }
            });
            
            // Start the client.
            ChannelFuture f = b.connect(host, port).sync(); // (5)

            // Wait until the connection is closed.
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
        }
    }
}
~~~

1. [`Bootstrap`](https://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html) is similar to [`ServerBootstrap`](https://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html) except that it's for non-server channels such as a client-side or connectionless channel.

   > [`Bootstrap`](https://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html) 和 [`ServerBootstrap`](https://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html) 很相似，它用于非Server管道，比如客户端或者无连接管道

2. If you specify only one [`EventLoopGroup`](https://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html), it will be used both as a boss group and as a worker group. The boss worker is not used for the client side though.

   > 如果您只指定了一个 EventLoopGroup，那么它将同时作为老板组和工作组使用。不过，boss worker并不用于客户端。

3. Instead of [`NioServerSocketChannel`](https://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html), [`NioSocketChannel`](https://netty.io/5.0/api/io/netty/channel/socket/nio/NioSocketChannel.html) is being used to create a client-side [`Channel`](https://netty.io/5.0/api/io/netty/channel/Channel.html).

   > 与[`NioServerSocketChannel`](https://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html)对应， [`NioSocketChannel`](https://netty.io/5.0/api/io/netty/channel/socket/nio/NioSocketChannel.html) 被用来创建一个客户端管道

4. Note that we do not use `childOption()` here unlike we did with `ServerBootstrap` because the client-side [`SocketChannel`](https://netty.io/5.0/api/io/netty/channel/socket/SocketChannel.html) does not have a parent.

   > 因为客户端 [`SocketChannel`](https://netty.io/5.0/api/io/netty/channel/socket/SocketChannel.html) 没有父系关系，所有 `childOption()` 不再被使用

5. We should call the `connect()` method instead of the `bind()` method.

   > 在客户端调用 `connect()` 方法而不是 `bind()` 方法。

As you can see, it is not really different from the the server-side code. What about the [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) implementation? It should receive a 32-bit integer from the server, translate it into a human readable format, print the translated time, and close the connection:

> 在本实例中， [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) 的实现类功能是从服务端接收一个32位的整数，并将其转换为人类可读的格式，打印转换花费的时间，并关闭连接。

```
package io.netty.example.time;

import java.util.Date;

public class TimeClientHandler extends ChannelHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf m = (ByteBuf) msg; // (1)
        try {
            long currentTimeMillis = (m.readUnsignedInt() - 2208988800L) * 1000L;
            System.out.println(new Date(currentTimeMillis));
            ctx.close();
        } finally {
            m.release();
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}
```

1. In TCP/IP, Netty reads the data sent from a peer into a [[`ByteBuf`](https://netty.io/5.0/api/io/netty/buffer/ByteBuf.html)].

It looks very simple and does not look any different from the server side example. However, this handler sometimes will refuse to work raising an `IndexOutOfBoundsException`. We discuss why this happens in the next section.

> 这个和客户端看着很像，但是这个处理器在碰到 `IndexOutOfBoundsException`时会拒绝执行，下部分讨论这个问题。

### Dealing with a Stream-based Transport

#### One Small Caveat of Socket Buffer

In a stream-based transport such as TCP/IP, received data is stored into a socket receive buffer. Unfortunately, the buffer of a stream-based transport is not a queue of packets but a queue of bytes. It means, even if you sent two messages as two independent packets, an operating system will not treat them as two messages but as just a bunch of bytes. Therefore, there is no guarantee that what you read is exactly what your remote peer wrote. For example, let us assume that the TCP/IP stack of an operating system has received three packets:

> 在基于流的传输中，比如TCP/IP，接收到的数据被存储到一个socket接收缓存区中，不幸的是，基于流传输的缓存区不是一个包队列，而是一个字节队列。就是说尽管你用两个包分别发了一条消息，操作系统处理时不认为这是两条消息，而是处理为一串字节。因此，你读到的内容不一定是你远程服务写的内容。假设一个操作系统的TCP/IP栈接收了3个数据包：

Because of this general property of a stream-based protocol, there's high chance of reading them in the following fragmented form in your application:

> 因为基于流的协议的共性，很有可能会将其处理为以下形式

Therefore, a receiving part, regardless it is server-side or client-side, should defrag the received data into one or more meaningful frames that could be easily understood by the application logic. In case of the example above, the received data should be framed like the following

> 因此，对于接收模块，无论是客户端还是服务端，都应该将接收到的数据转换为可以被应用逻辑容易理解的框架。

#### The First Solution

Now let us get back to the `TIME` client example. We have the same problem here. A 32-bit integer is a very small amount of data, and it is not likely to be fragmented often. However, the problem is that it can be fragmented, and the possibility of fragmentation will increase as the traffic increases.

> 在计时client的例子中，我们有一个同样的问题。32位的整数是一个很小的数据，不太可能被经常分段。然而问题是它可能会被分段，这个概率随着流量而增加。

The simplistic solution is to create an internal cumulative buffer and wait until all 4 bytes are received into the internal buffer. The following is the modified `TimeClientHandler` implementation that fixes the problem:

> 最简单的方法是创建一个内部累积缓存区，一次性将4个字节读到内部缓存区。以下是具体实现：

```java
package io.netty.example.time;

import java.util.Date;

public class TimeClientHandler extends ChannelHandlerAdapter {
    private ByteBuf buf;
    
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        buf = ctx.alloc().buffer(4); // (1)
    }
    
    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) {
        buf.release(); // (1)
        buf = null;
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf m = (ByteBuf) msg;
        buf.writeBytes(m); // (2)
        m.release();
        
        if (buf.readableBytes() >= 4) { // (3)
            long currentTimeMillis = (buf.readUnsignedInt() - 2208988800L) * 1000L;
            System.out.println(new Date(currentTimeMillis));
            ctx.close();
        }
    }
    
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}
```

1. A [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) has two life cycle listener methods: `handlerAdded()` and `handlerRemoved()`. You can perform an arbitrary (de)initialization task as long as it does not block for a long time.

   > 一个[`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) 有两个生命周期监听器方法： `handlerAdded()` and `handlerRemoved()`. 可以执行任意(反)初始化任务，只要它不会长时间阻塞。

2. First, all received data should be cumulated into `buf`.

   > 首先，所有接收到的数据被累积存到buf中

3. And then, the handler must check if `buf` has enough data, 4 bytes in this example, and proceed to the actual business logic. Otherwise, Netty will call the `channelRead()` method again when more data arrives, and eventually all 4 bytes will be cumulated.

   > 然后，处理器检查buf中是否有足够的数据，如果有则正常结束。否则Netty在更多数据进来时会继续调用 `channelRead()` 方法，直至buf有4个字节的数据

#### The Second Solution

Although the first solution has resolved the problem with the `TIME` client, the modified handler does not look that clean. Imagine a more complicated protocol which is composed of multiple fields such as a variable length field. Your [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) implementation will become unmaintainable very quickly.

> 虽然第一种方法已经解决了问题，但是存在一个问题：如果协议很复杂，由不同长度的多字段组成， [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) 实现将会很快变得无法维护。

As you may have noticed, you can add more than one [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) to a [`ChannelPipeline`](https://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html), and therefore, you can split one monolithic [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) into multiple modular ones to reduce the complexity of your application. For example, you could split `TimeClientHandler` into two handlers:

- `TimeDecoder` which deals with the fragmentation issue, and
- the initial simple version of `TimeClientHandler`.

> 之前说过，可以添加多个 [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) 到一个 [`ChannelPipeline`](https://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html)中，所以可以将一个大一统的 [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) 划分为多个 [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) ，减少应用的复杂度。例如可以将 `TimeClientHandler` 拆成两个处理器:
>
> - `TimeDecoder` which deals with the fragmentation issue, and
>
>   > 处理分段问题
>
> - the initial simple version of `TimeClientHandler`.
>
>   > 最开始简单版本的处理器

Fortunately, Netty provides an extensible class which helps you write the first one out of the box:

> 幸运的是，Netty 提供了一个可扩展的类，可以帮助您开箱即用地编写第一个类:

~~~java
package io.netty.example.time;

public class TimeDecoder extends ByteToMessageDecoder { // (1)
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) { // (2)
        if (in.readableBytes() < 4) {
            return; // (3)
        }
        
        out.add(in.readBytes(4)); // (4)
    }
}
~~~

1. [`ByteToMessageDecoder`](https://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html) is an implementation of [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) which makes it easy to deal with the fragmentation issue.

   > [`ByteToMessageDecoder`](https://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html) 是一个 [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) 的实现类，用来便捷的处理分块问题

2. [`ByteToMessageDecoder`](https://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html) calls the `decode()` method with an internally maintained cumulative buffer whenever new data is received.

   > 每当接收到新数据时，ByteToMessageDecoder 使用内部维护的累积缓冲区调用 decode ()方法。

3. `decode()` can decide to add nothing to `out` where there is not enough data in the cumulative buffer. [`ByteToMessageDecoder`](https://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html) will call `decode()` again when there is more data received.

   > 如果累积缓存区没有足够的数据，decode()方法不会向out中写任何内容，当再接收到数据时，ByteToMessageDecoder 会再次调用decode()方法。

4. If `decode()` adds an object to `out`, it means the decoder decoded a message successfully. [`ByteToMessageDecoder`](https://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html) will discard the read part of the cumulative buffer. Please remember that you don't need to decode multiple messages. [`ByteToMessageDecoder`](https://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html) will keep calling the `decode()` method until it adds nothing to `out`.

   > 如果decode()方法向out添加了一个对象，这意味着解码器成功解码了一条信息。ByteToMessageDecoder 会废弃累积缓存区的读取部分。开发者不用解码多条消息，ByteToMessageDecder 将继续调用 decode ()方法，直到它不向 out 添加任何内容为止。

Now that we have another handler to insert into the [`ChannelPipeline`](https://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html), we should modify the [`ChannelInitializer`](https://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html) implementation in the `TimeClient`:

> 在管道初始化时，需要将ByteToMessageDecder添加到ChannelPipeline中：

~~~JAVA
b.handler(new ChannelInitializer<SocketChannel>() {
    @Override
    public void initChannel(SocketChannel ch) throws Exception {
        ch.pipeline().addLast(new TimeDecoder(), new TimeClientHandler());
    }
});
~~~

If you are an adventurous person, you might want to try the [`ReplayingDecoder`](https://netty.io/5.0/api/io/netty/handler/codec/ReplayingDecoder.html) which simplifies the decoder even more. You will need to consult the API reference for more information though.

> ReplayingDecoder进一步简化了解码器的代码

~~~JAVA
public class TimeDecoder extends ReplayingDecoder<Void> {
    @Override
    protected void decode(
            ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        out.add(in.readBytes(4));
    }
}
~~~

Additionally, Netty provides out-of-the-box decoders which enables you to implement most protocols very easily and helps you avoid from ending up with a monolithic unmaintainable handler implementation. Please refer to the following packages for more detailed examples:

- [`io.netty.example.factorial`](https://netty.io/5.0/xref/io/netty/example/factorial/package-summary.html) for a binary protocol, and
- [`io.netty.example.telnet`](https://netty.io/5.0/xref/io/netty/example/telnet/package-summary.html) for a text line-based protocol.

### Speaking in POJO instead of `ByteBuf`

All the examples we have reviewed so far used a [`ByteBuf`](https://netty.io/5.0/api/io/netty/buffer/ByteBuf.html) as a primary data structure of a protocol message. In this section, we will improve the `TIME` protocol client and server example to use a POJO instead of a [`ByteBuf`](https://netty.io/5.0/api/io/netty/buffer/ByteBuf.html).

> 上述所有示例我们都是用ByteBuf作为一条协议消息的基础数据结构，这一小节会使用POJO来代替ByteBuf

The advantage of using a POJO in your [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html)s is obvious; your handler becomes more maintainable and reusable by separating the code which extracts information from `ByteBuf` out from the handler. In the `TIME` client and server examples, we read only one 32-bit integer and it is not a major issue to use `ByteBuf` directly. However, you will find it is necessary to make the separation as you implement a real world protocol.

> 通过分离从处理器中提取 ByteBuf 信息的代码，ChannelHandler变得更具可维护性和可重用性。上述的例子比较简单，真实世界的数据传输很复杂，需要更好的设计。

First, let us define a new type called `UnixTime`.

```java
package io.netty.example.time;

import java.util.Date;

public class UnixTime {

    private final long value;
    
    public UnixTime() {
        this(System.currentTimeMillis() / 1000L + 2208988800L);
    }
    
    public UnixTime(long value) {
        this.value = value;
    }
        
    public long value() {
        return value;
    }
        
    @Override
    public String toString() {
        return new Date((value() - 2208988800L) * 1000L).toString();
    }
}
```

We can now revise the `TimeDecoder` to produce a `UnixTime` instead of a [`ByteBuf`](https://netty.io/5.0/api/io/netty/buffer/ByteBuf.html).

> 修改TimeDecoder的代码，让其创建一个UnixTime而不是ByteBuf

```java
@Override
protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
    if (in.readableBytes() < 4) {
        return;
    }

    out.add(new UnixTime(in.readUnsignedInt()));
}
```

With the updated decoder, the `TimeClientHandler` does not use [`ByteBuf`](https://netty.io/5.0/api/io/netty/buffer/ByteBuf.html) anymore:

```java
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    UnixTime m = (UnixTime) msg;
    System.out.println(m);
    ctx.close();
}
```

Much simpler and elegant, right? The same technique can be applied on the server side. Let us update the `TimeServerHandler` first this time:

```java
@Override
public void channelActive(ChannelHandlerContext ctx) {
    ChannelFuture f = ctx.writeAndFlush(new UnixTime());
    f.addListener(ChannelFutureListener.CLOSE);
}
```

Now, the only missing piece is an encoder, which is an implementation of [`ChannelHandler`](https://netty.io/5.0/api/io/netty/channel/ChannelHandler.html) that translates a `UnixTime` back into a [`ByteBuf`](https://netty.io/5.0/api/io/netty/buffer/ByteBuf.html). It's much simpler than writing a decoder because there's no need to deal with packet fragmentation and assembly when encoding a message.

> 服务端改造后，需要一个encoder将时间处理为字节，因为不用考虑包分块的问题，这个代码简单很多

```java
package io.netty.example.time;

public class TimeEncoder extends ChannelHandlerAdapter {
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
        UnixTime m = (UnixTime) msg;
        ByteBuf encoded = ctx.alloc().buffer(4);
        encoded.writeInt((int) m.value());
        ctx.write(encoded, promise); // (1)
    }
}
```

1. There are a few important things to notice in this handler method:

   First, we pass the original [`ChannelPromise`](https://netty.io/5.0/api/io/netty/channel/ChannelPromise.html) as-is so that Netty marks it as success or failure when the encoded data is actually written out to the wire.

   Second, we did not call `ctx.flush()`. There is a separate handler method `void flush(ChannelHandlerContext ctx)` which is purposed to override the `flush()` operation.

To simplify even further, you can make use of [`MessageToByteEncoder`](https://netty.io/5.0/api/io/netty/handler/codec/MessageToByteEncoder.html):

```
public class TimeEncoder extends MessageToByteEncoder<UnixTime> {
    @Override
    protected void encode(ChannelHandlerContext ctx, UnixTime msg, ByteBuf out) {
        out.writeInt((int) msg.value());
    }
}
```

The last task left is to insert a `TimeEncoder` into the [`ChannelPipeline`](https://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html) on the server side before the `TimeServerHandler`, and it is left as a trivial exercise.

### Shutting Down Your Application

Shutting down a Netty application is usually as simple as shutting down all [`EventLoopGroup`](https://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html)s you created via `shutdownGracefully()`. It returns a [`Future`](https://netty.io/5.0/api/io/netty/util/concurrent/Future.html) that notifies you when the [`EventLoopGroup`](https://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html) has been terminated completely and all [`Channel`](https://netty.io/5.0/api/io/netty/channel/Channel.html)s that belong to the group have been closed.

### Summary

In this chapter, we had a quick tour of Netty with a demonstration on how to write a fully working network application on top of Netty.

There is more detailed information about Netty in the upcoming chapters. We also encourage you to review the Netty examples in the [`io.netty.example`](https://github.com/netty/netty/tree/master/example/src/main/java/io/netty/example) package.

Please also note that [the community](https://netty.io/community.html) is always waiting for your questions and ideas to help you and keep improving Netty and its documentation based on your feed back.